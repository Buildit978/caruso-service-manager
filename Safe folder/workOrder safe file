// for safe temp keeping   get with summary
router.get(
  "/",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const accountId = req.accountId;
      if (!accountId) {
        return res.status(400).json({ message: "Missing accountId" });
      }

      const { sortBy, sortDir } = req.query;

      const baseQuery: any = { accountId };

      // ðŸ”¹ Sorting options:
      // - createdAt       (default)
      // - serviceDate
      // - status         (simple alphabetical for now)
      let sort: Record<string, 1 | -1>;
      const dir: 1 | -1 =
        sortDir === "asc"
          ? 1
          : sortDir === "desc"
          ? -1
          : -1; // default desc

      switch (sortBy) {
        case "serviceDate":
          sort = { serviceDate: dir, createdAt: dir };
          break;
        case "status":
          sort = { status: dir, createdAt: dir };
          break;
        case "createdAt":
        default:
          sort = { createdAt: -1 }; // newest first by default
          break;
      }

      const workOrders = await WorkOrder.find(baseQuery)
        .sort(sort)
        .lean();

      res.json(workOrders);
    } catch (err) {
      next(err);
    }
  }
);      match.customerId = customerId;
            }

            // Optional filter: date range
            if (typeof from === 'string' || typeof to === 'string') {
                match.date = {};

                if (typeof from === 'string' && from.trim() !== '') {
                    const fromDate = new Date(from);
                    if (!isNaN(fromDate.getTime())) {
                        match.date.$gte = fromDate;
                    }
                }

                if (typeof to === 'string' && to.trim() !== '') {
                    const toDate = new Date(to);
                    if (!isNaN(toDate.getTime())) {
                        match.date.$lte = toDate;
                    }
                }

                if (Object.keys(match.date).length === 0) {
                    delete match.date;
                }
            }

            // Aggregate counts by status
            const result = await WorkOrder.aggregate([
                { $match: match },
                {
                    $group: {
                        _id: '$status',
                        count: { $sum: 1 },
                    },
                },
            ]);

            // Normalize into a fixed shape
            const summary: Record<string, number> = {
                open: 0,
                in_progress: 0,
                completed: 0,
                invoiced: 0,
            };

            for (const row of result) {
                summary[row._id] = row.count;
            }

            res.json(summary);
        } catch (err) {
            next(err);
        }
    }
);